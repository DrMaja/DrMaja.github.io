<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game - DrMaja's Website</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        /* Game-specific styles */
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 2rem;
        }
        .drop-row {
            display: flex;
            gap: 2rem;
            margin-bottom: 2rem;
        }
        .drop-zone {
            width: 70px;
            height: 70px;
            border: 4px solid #222;
            border-radius: 10px;
            background: #f7f9fa;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            margin: 0 0.5rem;
        }
        .drag-row {
            display: flex;
            gap: 2rem;
        }
        .draggable-square {
            width: 60px;
            height: 60px;
            border-radius: 8px;
            cursor: grab;
            border: 2px solid #222;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            user-select: none;
        }
        .draggable-square.red { background: #e25555; }
        .draggable-square.yellow { background: #ffe066; }
        .draggable-square.blue { background: #4a90e2; }
        .draggable-square.green { background: #4caf50; }
        .draggable-square.orange { display: none; }
        .dragging {
            opacity: 0.6;
        }
        .order-hint {
            margin-bottom: 1rem;
            font-size: 1.1rem;
            font-weight: bold;
            letter-spacing: 0.1em;
        }
        .order-color {
            display: inline-block;
            width: 24px;
            height: 24px;
            border-radius: 6px;
            margin: 0 4px;
            vertical-align: middle;
            border: 2px solid #222;
        }
        .order-color.blue { background: #4a90e2; }
        .order-color.red { background: #e25555; }
        .order-color.yellow { background: #ffe066; }
        .order-color.green { background: #4caf50; }
        .order-color.orange { display: none; }
        .hint-row {
            margin-bottom: 1rem;
            font-size: 1.1rem;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 0.5rem;
            flex-wrap: nowrap;
        }
        .hint-row .hint-title {
            white-space: nowrap;
        }
        .hint-list {
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
        }
        .hint-pair {
            display: flex;
            align-items: center;
            margin-right: 0;
        }
        .hint-color {
            display: inline-block;
            width: 28px;
            height: 28px;
            border-radius: 6px;
            border: 2px solid #222;
            margin-right: 2px;
        }
        .hint-color.blue { background: #4a90e2; }
        .hint-color.red { background: #e25555; }
        .hint-color.yellow { background: #ffe066; }
        .hint-color.green { background: #4caf50; }
        .hint-color.orange { display: none; }
        .highlight-pair {
            outline: 3px solid #e25555;
            outline-offset: 2px;
            border-radius: 8px;
            background: #ffd6d6;
        }

        @media (max-width: 600px) {
            .drop-row, .drag-row {
                gap: 1rem;
            }
            .drop-zone, .draggable-square {
                width: 48px;
                height: 48px;
                font-size: 1.1rem;
            }
            .hint-color {
                width: 20px;
                height: 20px;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Deduce the correct order of the blocks to win the game!
        </h1>
    </header>
    <main>
        <div class="game-container">
            <div id="timer" style="font-size:1.3rem; font-weight:bold; margin-bottom:1rem;">Time: 0s</div>
            <div class="hint-row" id="hint-row"></div>
            <div class="drop-row">
                <div class="drop-zone" id="drop-0" ondragover="allowDrop(event)" ondrop="drop(event)"></div>
                <div class="drop-zone" id="drop-1" ondragover="allowDrop(event)" ondrop="drop(event)"></div>
                <div class="drop-zone" id="drop-2" ondragover="allowDrop(event)" ondrop="drop(event)"></div>
                <div class="drop-zone" id="drop-3" ondragover="allowDrop(event)" ondrop="drop(event)"></div>
            </div>
            <div class="drag-row" id="drag-row"
                ondragover="allowDrop(event)"
                ondrop="dropToDragRow(event)">
                <div class="draggable-square blue" id="blue" draggable="true" ondragstart="drag(event)"></div>
                <div class="draggable-square red" id="red" draggable="true" ondragstart="drag(event)"></div>
                <div class="draggable-square yellow" id="yellow" draggable="true" ondragstart="drag(event)"></div>
                <div class="draggable-square green" id="green" draggable="true" ondragstart="drag(event)"></div>
            </div>
        </div>
        <button class="heart-btn" onclick="location.href='index.html'">Back to Home</button>
        <button class="heart-btn" onclick="resetGame()">New Game</button>
        <button class="heart-btn" onclick="resetOrder()">Reset Order</button>
        <button class="heart-btn" onclick="checkOrder()">Check Order</button>
    </main>
    <footer>
        <p>&copy; 2025 DrMaja. All rights reserved.</p>
    </footer>
    <script>
        // Drag and drop logic
        function allowDrop(ev) {
            ev.preventDefault();
        }
        // Track the currently dragged element
        let currentlyDraggedId = null;

        function drag(ev) {
            ev.dataTransfer.setData("text", ev.target.id);
            currentlyDraggedId = ev.target.id;
            setTimeout(() => {
                ev.target.classList.add('dragging');
            }, 0);
        }
        function drop(ev) {
            ev.preventDefault();
            const data = ev.dataTransfer.getData("text");
            const dragged = document.getElementById(data);
            // Only allow one square per drop zone
            if (ev.target.classList.contains('drop-zone') && ev.target.children.length === 0) {
                ev.target.appendChild(dragged);
                dragged.classList.remove('dragging');
                // checkOrder(); // removed, now only on button press
            }
        }

        function dropToDragRow(ev) {
            ev.preventDefault();
            const data = ev.dataTransfer.getData("text");
            const dragged = document.getElementById(data);
            const dragRow = document.getElementById('drag-row');
            if (dragged && !dragRow.contains(dragged)) {
                dragRow.appendChild(dragged);
                dragged.classList.remove('dragging');
                // checkOrder(); // removed, now only on button press
            }
            currentlyDraggedId = null;
        }

        // Allow dragging squares back to the drag-row
        document.querySelectorAll('.draggable-square').forEach(sq => {
            sq.ondragend = function() {
                this.classList.remove('dragging');
            };
        });
        // Make drag-row a drop target to return squares
        document.addEventListener('DOMContentLoaded', function() {
            const dragRow = document.querySelector('.drag-row');
            dragRow.ondragover = allowDrop;
            dragRow.ondrop = function(ev) {
                ev.preventDefault();
                const data = ev.dataTransfer.getData("text");
                const dragged = document.getElementById(data);
                if (!dragRow.contains(dragged)) {
                    dragRow.appendChild(dragged);
                    dragged.classList.remove('dragging');
                    // checkOrder(); // removed, now only on button press
                }
            };

            // Add a drop handler to the document body to catch drops outside valid zones
            document.body.addEventListener('dragover', function(ev) {
                ev.preventDefault();
            });
            document.body.addEventListener('drop', function(ev) {
                // Only handle if not dropped on a drop-zone or drag-row
                if (
                    !ev.target.classList.contains('drop-zone') &&
                    !ev.target.classList.contains('drag-row') &&
                    currentlyDraggedId
                ) {
                    const dragRow = document.getElementById('drag-row');
                    const dragged = document.getElementById(currentlyDraggedId);
                    if (dragged && !dragRow.contains(dragged)) {
                        dragRow.appendChild(dragged);
                        dragged.classList.remove('dragging');
                        checkWin();
                    }
                    currentlyDraggedId = null;
                }
            });
        });

        // Store the correct order globally
        let correctOrder = [];

        // All possible color ids
        const colorIds = ['blue', 'red', 'yellow', 'green'];

        // Utility to shuffle an array
        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Find the minimal set of invalid pairs so that only the correct order is possible
        function getMinimalInvalidPairs(order) {
            // All possible pairs (excluding self-pairs)
            let allPairs = [];
            for (let i = 0; i < colorIds.length; i++) {
                for (let j = 0; j < colorIds.length; j++) {
                    if (i !== j) allPairs.push([colorIds[i], colorIds[j]]);
                }
            }
            // Valid pairs in the correct order
            let validPairs = new Set();
            for (let i = 0; i < order.length - 1; i++) {
                validPairs.add(order[i] + '-' + order[i+1]);
            }
            // The minimal set of invalid pairs is all pairs except the valid ones
            let minimalInvalidPairs = allPairs.filter(pair => !validPairs.has(pair[0] + '-' + pair[1]));
            return minimalInvalidPairs;
        }

        // Store last guess to highlight invalid pairs in hint
        let lastInvalidPairsInGuess = [];

        function showHint() {
            const hintRow = document.getElementById('hint-row');
            const pairs = getMinimalInvalidPairs(correctOrder);

            // Highlight pairs that are present as adjacent pairs in the user's last guess
            let highlightPairs = new Set(
                (lastInvalidPairsInGuess || []).map(pair => pair[0] + '-' + pair[1])
            );

            // Split pairs into 4 columns as equally as possible
            const colCount = 4;
            const perCol = Math.ceil(pairs.length / colCount);
            let columns = Array.from({length: colCount}, () => []);
            pairs.forEach((pair, idx) => {
                columns[idx % colCount].push(pair);
            });

            hintRow.innerHTML =
                `<span class="hint-title">Hint: The following pairs <b>never</b> appear next to each other:</span>`
                + `<div style="display: flex; gap: 2.5rem;">`
                + columns.map(colPairs =>
                    `<div class="hint-list">` +
                    colPairs.map(pair => {
                        const key = pair[0] + '-' + pair[1];
                        const highlight = highlightPairs.has(key) ? ' highlight-pair' : '';
                        return `<span class="hint-pair${highlight}"><span class="hint-color ${pair[0]}"></span><span class="hint-color ${pair[1]}"></span></span>`;
                    }).join('') +
                    `</div>`
                ).join('') +
                `</div>`;
        }

        function highlightInvalidPairs(order) {
            const minimalInvalidPairs = getMinimalInvalidPairs(correctOrder);

            // Find all adjacent pairs in the user's guess that are invalid
            let foundInvalid = [];
            for (let i = 0; i < order.length - 1; i++) {
                if (order[i] && order[i+1]) {
                    let pair = [order[i], order[i+1]];
                    if (minimalInvalidPairs.some(p => p[0] === pair[0] && p[1] === pair[1])) {
                        foundInvalid.push(pair);
                    }
                }
            }
            lastInvalidPairsInGuess = foundInvalid;
            showHint();
        }

        function resetBlocks(incorrectIndexes = [0,1,2,3]) {
            const dragRow = document.querySelector('.drag-row');
            incorrectIndexes.forEach(i => {
                const dz = document.getElementById('drop-' + i);
                if (dz && dz.children.length > 0) {
                    dragRow.appendChild(dz.children[0]);
                }
            });
        }

        // Timer variables
        let timerInterval = null;
        let timerSeconds = 0;
        let timerRunning = false;

        function startTimer() {
            if (timerRunning) return;
            timerRunning = true;
            timerInterval = setInterval(() => {
                timerSeconds++;
                updateTimerDisplay();
            }, 1000);
        }

        function stopTimer() {
            timerRunning = false;
            clearInterval(timerInterval);
        }

        function resetTimer() {
            stopTimer();
            timerSeconds = 0;
            updateTimerDisplay();
        }

        function updateTimerDisplay() {
            document.getElementById('timer').textContent = `Time: ${timerSeconds}s`;
        }

        function checkOrder() {
            const order = [];
            for (let i = 0; i < 4; i++) {
                const dz = document.getElementById('drop-' + i);
                if (dz.children.length > 0) {
                    order.push(dz.children[0].id);
                } else {
                    order.push(null);
                }
            }
            // Only check if all drop zones are filled
            if (order.every(x => x !== null)) {
                let correct = true;
                let incorrectIndexes = [];
                for (let i = 0; i < 4; i++) {
                    if (order[i] !== correctOrder[i]) {
                        correct = false;
                        incorrectIndexes.push(i);
                    }
                }
                if (correct) {
                    setTimeout(() => {
                        lastInvalidPairsInGuess = [];
                        showHint();
                        stopTimer();
                        alert('You win!');
                    }, 100);
                } else {
                    highlightInvalidPairs(order);
                    setTimeout(() => {
                        alert('Try again!');
                        resetBlocks(incorrectIndexes);
                    }, 100);
                }
            } else {
                // Clear highlights if not all filled
                lastInvalidPairsInGuess = [];
                showHint();
            }
        }

        function resetGame() {
            // Reshuffle correct order
            correctOrder = shuffle(colorIds.slice());
            // Move all blocks back to drag row
            const dragRow = document.querySelector('.drag-row');
            colorIds.forEach(id => {
                const el = document.getElementById(id);
                if (el && !dragRow.contains(el)) {
                    dragRow.appendChild(el);
                }
            });
            lastInvalidPairsInGuess = [];
            showHint();
            resetTimer();
            startTimer();
        }

        function resetOrder() {
            const dragRow = document.getElementById('drag-row');
            // Move all blocks back to drag row
            ['blue', 'red', 'yellow', 'green'].forEach(id => {
                const el = document.getElementById(id);
                if (el && !dragRow.contains(el)) {
                    dragRow.appendChild(el);
                }
            });
        }

        // Touch support for drag and drop
        function enableTouchDnD() {
            // Helper to get element at touch position
            function getDropTarget(touch) {
                const el = document.elementFromPoint(touch.clientX, touch.clientY);
                if (!el) return null;
                if (el.classList.contains('drop-zone')) return el;
                if (el.classList.contains('drag-row')) return el;
                // If child of drop-zone or drag-row
                if (el.parentElement && el.parentElement.classList.contains('drop-zone')) return el.parentElement;
                if (el.parentElement && el.parentElement.classList.contains('drag-row')) return el.parentElement;
                return null;
            }

            let touchDragEl = null;
            let origParent = null;
            let origNext = null;

            document.querySelectorAll('.draggable-square').forEach(el => {
                el.addEventListener('touchstart', function(e) {
                    if (e.touches.length > 1) return;
                    touchDragEl = el;
                    origParent = el.parentElement;
                    origNext = el.nextElementSibling;
                    el.classList.add('dragging');
                    el.style.zIndex = 1000;
                    el.style.position = 'absolute';
                    el.style.pointerEvents = 'none';
                    document.body.appendChild(el);
                    moveAt(e.touches[0]);
                    e.preventDefault();
                }, {passive: false});

                function moveAt(touch) {
                    touchDragEl.style.left = (touch.clientX - touchDragEl.offsetWidth / 2) + 'px';
                    touchDragEl.style.top = (touch.clientY - touchDragEl.offsetHeight / 2) + 'px';
                }

                el.addEventListener('touchmove', function(e) {
                    if (!touchDragEl) return;
                    moveAt(e.touches[0]);
                    e.preventDefault();
                }, {passive: false});

                el.addEventListener('touchend', function(e) {
                    if (!touchDragEl) return;
                    touchDragEl.classList.remove('dragging');
                    touchDragEl.style.position = '';
                    touchDragEl.style.left = '';
                    touchDragEl.style.top = '';
                    touchDragEl.style.zIndex = '';
                    touchDragEl.style.pointerEvents = '';

                    let dropTarget = getDropTarget(e.changedTouches[0]);
                    if (dropTarget && dropTarget.classList.contains('drop-zone') && dropTarget.children.length === 0) {
                        dropTarget.appendChild(touchDragEl);
                    } else if (dropTarget && dropTarget.classList.contains('drag-row')) {
                        dropTarget.appendChild(touchDragEl);
                    } else {
                        // If dropped elsewhere, return to drag-row
                        document.getElementById('drag-row').appendChild(touchDragEl);
                    }
                    touchDragEl = null;
                    origParent = null;
                    origNext = null;
                    // Do not check order automatically
                }, {passive: false});
            });
        }

        document.addEventListener('DOMContentLoaded', function() {
            // Randomize correct order
            correctOrder = shuffle(colorIds.slice());
            const dragRow = document.querySelector('.drag-row');
            dragRow.ondragover = allowDrop;
            dragRow.ondrop = function(ev) {
                ev.preventDefault();
                const data = ev.dataTransfer.getData("text");
                const dragged = document.getElementById(data);
                if (!dragRow.contains(dragged)) {
                    dragRow.appendChild(dragged);
                    dragged.classList.remove('dragging');
                    // checkOrder(); // removed, now only on button press
                }
            };
            lastInvalidPairsInGuess = [];
            showHint();
            resetTimer();
            startTimer();
            enableTouchDnD();
        });
    </script>
</body>
</html>
